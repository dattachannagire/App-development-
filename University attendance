# University Attendance App — Flutter

This canvas contains:
1. A **complete Minimal Flutter project** (ready-to-run) implementing the core minimal demo features using Firebase: Authentication, Instructor creates course & session (PIN), Student joins session with PIN and marks attendance, Firestore storage, and simple UI. Replace Firebase config files to run.

2. A **Full project plan & file map** with key code snippets for advanced features (offline sync, CSV export, QR join, selfie validation, role-based security rules, analytics). Use this to expand the minimal app into a full production-ready app.

---

## Important setup notes (before running)
1. Create a Firebase project at https://console.firebase.google.com/
2. Add Android and/or iOS app and download `google-services.json` (Android) and/or `GoogleService-Info.plist` (iOS). Place them in android/app/ and ios/Runner/ respectively.
3. Enable **Authentication → Email/Password**.
4. Create Firestore database in **test** mode for demo (change rules before production).
5. In `pubspec.yaml` below, run `flutter pub get`.

---

## pubspec.yaml
```yaml
name: university_attendance_app_minimal
description: Minimal demo of University Attendance App
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=2.17.0 <3.0.0'

dependencies:
  flutter:
    sdk: flutter
  firebase_core: ^2.8.0
  firebase_auth: ^4.4.0
  cloud_firestore: ^4.6.0
  provider: ^6.0.5

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
```

---

## Minimal app — lib/main.dart (single-file app for demo)

Paste into `lib/main.dart`. This example keeps UI minimal but complete.

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';

// NOTE: Add your generated firebase_options.dart or manual initialization per platform.

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'University Attendance - Minimal',
      theme: ThemeData(primarySwatch: Colors.indigo),
      home: AuthGate(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class AuthGate extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) return Scaffold(body: Center(child: CircularProgressIndicator()));
        if (!snapshot.hasData) return LoginPage();
        return RoleRouter(user: snapshot.data!);
      },
    );
  }
}

class LoginPage extends StatefulWidget {
  @override
  _LoginPageState createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _email = TextEditingController();
  final _password = TextEditingController();
  bool _isLoading = false;

  Future<void> _register(String role) async {
    try {
      setState(() => _isLoading = true);
      final cred = await FirebaseAuth.instance.createUserWithEmailAndPassword(email: _email.text.trim(), password: _password.text.trim());
      final uid = cred.user!.uid;
      await FirebaseFirestore.instance.collection('users').doc(uid).set({
        'email': _email.text.trim(),
        'role': role,
        'name': '',
      });
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Register error: $e')));
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _login() async {
    try {
      setState(() => _isLoading = true);
      await FirebaseAuth.instance.signInWithEmailAndPassword(email: _email.text.trim(), password: _password.text.trim());
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Login error: $e')));
    } finally {
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Login / Register')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          children: [
            TextField(controller: _email, decoration: InputDecoration(labelText: 'Email')),
            TextField(controller: _password, decoration: InputDecoration(labelText: 'Password'), obscureText: true),
            SizedBox(height: 16),
            if (_isLoading) CircularProgressIndicator(),
            if (!_isLoading) Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                ElevatedButton(onPressed: _login, child: Text('Login')),
                ElevatedButton(onPressed: () => _showRegisterDialog(), child: Text('Register')),
              ],
            )
          ],
        ),
      ),
    );
  }

  void _showRegisterDialog() {
    showDialog(context: context, builder: (c) {
      return AlertDialog(
        title: Text('Register as'),
        content: Column(mainAxisSize: MainAxisSize.min, children: [
          ElevatedButton(onPressed: () { Navigator.of(context).pop(); _register('student'); }, child: Text('Student')),
          ElevatedButton(onPressed: () { Navigator.of(context).pop(); _register('instructor'); }, child: Text('Instructor')),
        ]),
      );
    });
  }
}

class RoleRouter extends StatelessWidget {
  final User user;
  RoleRouter({required this.user});

  Future<String> _role() async {
    final doc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
    if (!doc.exists) return 'student';
    return (doc.data()?['role'] ?? 'student') as String;
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<String>(future: _role(), builder: (context, snap) {
      if (!snap.hasData) return Scaffold(body: Center(child: CircularProgressIndicator()));
      final role = snap.data!;
      if (role == 'instructor') return InstructorHome();
      return StudentHome();
    });
  }
}

// ---------------- Instructor Home ----------------
class InstructorHome extends StatefulWidget {
  @override
  _InstructorHomeState createState() => _InstructorHomeState();
}

class _InstructorHomeState extends State<InstructorHome> {
  final _courseName = TextEditingController();

  Stream<QuerySnapshot> _coursesStream() {
    final uid = FirebaseAuth.instance.currentUser!.uid;
    return FirebaseFirestore.instance.collection('courses').where('instructorId', isEqualTo: uid).snapshots();
  }

  Future<void> _createCourse() async {
    if (_courseName.text.trim().isEmpty) return;
    final uid = FirebaseAuth.instance.currentUser!.uid;
    await FirebaseFirestore.instance.collection('courses').add({
      'title': _courseName.text.trim(),
      'instructorId': uid,
      'createdAt': FieldValue.serverTimestamp(),
    });
    _courseName.clear();
  }

  Future<void> _startSession(String courseId) async {
    final pin = (1000 + (DateTime.now().millisecondsSinceEpoch % 9000)).toString();
    await FirebaseFirestore.instance.collection('attendance_sessions').add({
      'courseId': courseId,
      'instructorId': FirebaseAuth.instance.currentUser!.uid,
      'pin': pin,
      'active': true,
      'startTime': FieldValue.serverTimestamp(),
    });
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Session started. PIN: $pin')));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Instructor Home'), actions: [IconButton(onPressed: () => FirebaseAuth.instance.signOut(), icon: Icon(Icons.logout))]),
      body: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(children: [
          Row(children: [Expanded(child: TextField(controller: _courseName, decoration: InputDecoration(hintText: 'Course title'))), SizedBox(width: 8), ElevatedButton(onPressed: _createCourse, child: Text('Create'))]),
          SizedBox(height: 12),
          Expanded(child: StreamBuilder<QuerySnapshot>(stream: _coursesStream(), builder: (context, snap) {
            if (!snap.hasData) return Center(child: CircularProgressIndicator());
            final docs = snap.data!.docs;
            if (docs.isEmpty) return Center(child: Text('No courses.'));
            return ListView.builder(itemCount: docs.length, itemBuilder: (c, i) {
              final d = docs[i];
              return Card(
                child: ListTile(
                  title: Text(d['title'] ?? ''),
                  subtitle: Text('CourseId: ${d.id}'),
                  trailing: ElevatedButton(onPressed: () => _startSession(d.id), child: Text('Start Session')),
                ),
              );
            });
          }))
        ]),
      ),
    );
  }
}

// ---------------- Student Home ----------------
class StudentHome extends StatefulWidget {
  @override
  _StudentHomeState createState() => _StudentHomeState();
}

class _StudentHomeState extends State<StudentHome> {
  final _pinCtrl = TextEditingController();

  Future<void> _joinWithPin() async {
    final pin = _pinCtrl.text.trim();
    if (pin.isEmpty) return;
    final sessionQuery = await FirebaseFirestore.instance.collection('attendance_sessions').where('pin', isEqualTo: pin).where('active', isEqualTo: true).limit(1).get();
    if (sessionQuery.docs.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('No active session with that PIN')));
      return;
    }

    final session = sessionQuery.docs.first;
    final sessionId = session.id;
    final courseId = session['courseId'];
    final uid = FirebaseAuth.instance.currentUser!.uid;

    // write attendance record (idempotent check)
    final existing = await FirebaseFirestore.instance.collection('attendance_records')
        .where('sessionId', isEqualTo: sessionId).where('studentId', isEqualTo: uid).limit(1).get();
    if (existing.docs.isNotEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('You have already marked attendance.')));
      return;
    }

    await FirebaseFirestore.instance.collection('attendance_records').add({
      'sessionId': sessionId,
      'courseId': courseId,
      'studentId': uid,
      'status': 'present',
      'timestamp': FieldValue.serverTimestamp(),
    });

    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Attendance marked.')));
  }

  Stream<QuerySnapshot> _myCoursesStream() {
    // Simple demo: show all courses (in real app filter by enrollment)
    return FirebaseFirestore.instance.collection('courses').snapshots();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Student Home'), actions: [IconButton(onPressed: () => FirebaseAuth.instance.signOut(), icon: Icon(Icons.logout))]),
      body: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(children: [
          TextField(controller: _pinCtrl, decoration: InputDecoration(labelText: 'Enter session PIN to join')),
          SizedBox(height: 8),
          ElevatedButton(onPressed: _joinWithPin, child: Text('Join Session')),
          SizedBox(height: 12),
          Expanded(child: StreamBuilder<QuerySnapshot>(stream: _myCoursesStream(), builder: (context, snap) {
            if (!snap.hasData) return Center(child: CircularProgressIndicator());
            final docs = snap.data!.docs;
            if (docs.isEmpty) return Center(child: Text('No courses available.'));
            return ListView.builder(itemCount: docs.length, itemBuilder: (c, i) {
              final d = docs[i];
              return Card(child: ListTile(title: Text(d['title'] ?? ''), subtitle: Text('CourseId: ${d.id}')));
            });
          }))
        ]),
      ),
    );
  }
}
```

---

## Full Project — Plan & Key Files
Below is a blueprint to expand the minimal demo into a full-featured app. Use this as a direct checklist when you build the full project.

### File structure (recommended)
```
lib/
  main.dart
  firebase_options.dart  // generated by FlutterFire CLI
  services/
    auth_service.dart
    firestore_service.dart
    storage_service.dart
    sync_queue.dart
  models/
    user.dart
    course.dart
    session.dart
    attendance_record.dart
  screens/
    auth/
      login.dart
      register.dart
    student/
      student_home.dart
      attendance_history.dart
    instructor/
      instructor_home.dart
      manage_roster.dart
      start_session.dart
      reports.dart
  widgets/
    course_card.dart
    attendance_tile.dart

assets/
  icons/
  sounds/
```

### Advanced features to implement
- Enrollment management (students enroll in courses)
- Session PIN expiry & QR code generation (use `qr_flutter` package)
- Face/selfie verification (upload to Storage, manual review or ML)
- Offline queue: store pending writes locally (Hive) and flush on reconnect
- CSV export: build CSV client-side or use Cloud Function to generate and email
- Role-based Cloud Functions for admin operations

### Firestore security rules (production-ready)
- Use role checks from users collection (server should also set claims for stronger security)
- Enforce session `active` status and session time window for writes
- Limit read access to course participants and instructors

### UX & Design
- Use Material 3 / adaptive UI
- Add onboarding, tooltips, and permission rationales (camera, location)
- Accessibility: large tap targets, readable fonts, contrast

### Testing
- Unit tests for services (Auth, Firestore reads/writes)
- Integration tests for critical flows (student check-in, instructor session create)

---

## What I can generate next (pick any):
- ✅ **Full Flutter project** (code for all files listed above) — I’ll produce it as a canvas file or multiple files on request.
- ✅ **APK / AAB** build commands and CI config for building the app.
- ✅ **Cloud Functions** for CSV export & server-side attendance verification.
- ✅ **Detailed Firestore security rules** tailored to the full app.

Tell me which next step you want me to generate now: **Full project code**, **Security rules**, **Cloud Functions**, or **APK build script**. If you want the full project, I will generate the code for all the major files mentioned in the Plan.
